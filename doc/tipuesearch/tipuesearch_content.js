var tipuesearch = {"pages":[{"text":"ooflib This is my attempt to develop pure fortran library approximating some usefull\nconcepts from C++ STL or Boost libraries. Note - the library relies highly on Fortran 2003/2008 features, so it needs decent\n  compiler (ested with gfortran-5.2) Developer Info Jiri Furst","tags":"home","loc":"index.html","title":" ooflib "},{"text":"Source Code !====================================================================== ! !          Copyright Jiri Furst 2013 ! Distributed under the Boost Software License, Version 1.0. !    (See accompanying file LICENSE_1_0.txt or copy at !          http://www.boost.org/LICENSE_1_0.txt) ! !---------------------------------------------------------------------- ! !  MODULE: queues ! !> @author Jiri Furst ! !  DESCRIPTION: !> The module defines simple queue ! !====================================================================== module queues use objects use lists use iterators use collections private !> The simple queue !! type , public , extends ( collection ) :: queue type ( list ), private :: container contains procedure :: is_empty procedure :: size procedure :: push procedure :: add procedure :: top procedure :: pop procedure :: clear procedure :: iterator => q_iterator end type queue public :: queues_test contains logical function is_empty ( self ) class ( queue ), intent ( in ) :: self is_empty = self % container % is_empty () end function is_empty integer function size ( self ) class ( queue ), intent ( in ) :: self size = self % container % size () end function size subroutine clear ( self ) class ( queue ), intent ( inout ) :: self call self % container % clear () end subroutine clear function q_iterator ( self ) class ( queue ), target , intent ( in ) :: self class ( iterator ), allocatable :: q_iterator allocate ( q_iterator , source = self % container % iterator ()) end function q_iterator subroutine push ( self , o ) class ( queue ), intent ( inout ) :: self class ( * ), intent ( in ) :: o call self % container % add ( o ) end subroutine push subroutine add ( self , o ) class ( queue ), intent ( inout ) :: self class ( * ), intent ( in ) :: o call self % container % add ( o ) end subroutine add function top ( self ) class ( queue ), intent ( inout ) :: self class ( * ), pointer :: top class ( iterator ), allocatable :: iter allocate ( iter , source = self % container % iterator ()) top => iter % next () end function top subroutine pop ( self ) class ( queue ), intent ( inout ) :: self class ( iterator ), allocatable :: iter class ( * ), pointer :: top allocate ( iter , source = self % container % iterator ()) top => iter % next () call iter % remove () end subroutine pop !====================================================================== ! TEST !====================================================================== subroutine queues_test print * , \"Homogeneous queue tests:\" call integer_queue_test () call generic_queue_test () print * contains subroutine integer_queue_test () type ( queue ) :: q integer :: i class ( * ), pointer :: o print * , \" - checking integer queue\" if ( q % size () /= 0 ) stop \"empty queue size /= 0!\" call q % push ( 1 ) call q % push ( 2 ) call q % push ( 3 ) if ( q % size () /= 3 ) stop \"short queue size /= 3!\" call check_array ( q % iterator (), [ 1 , 2 , 3 ] ) o => q % top () select type ( o ) type is ( integer ) if ( o /= 1 ) stop \"Wrong element, q%top() /= 1\" end select o => q % top () select type ( o ) type is ( integer ) if ( o /= 1 ) stop \"Wrong element, q%top() /= 1\" end select call q % pop () if ( q % size () /= 2 ) stop \"short queue size /= 2!\" o => q % top () select type ( o ) type is ( integer ) if ( o /= 2 ) stop \"Wrong element, q%top() /= 2\" end select call q % clear () if ( q % size () /= 0 ) stop \"empty list size /= 0!\" end subroutine integer_queue_test subroutine generic_queue_test type ( queue ) :: q class ( * ), pointer :: o print * , \" - checking generic queue\" call q % push ( \"Hi\" ) call q % push ( 42 ) call q % push ( 3.14 d0 ) if ( q % size () /= 3 ) stop \"short queue size /= 3!\" o => q % top () select type ( o ) type is ( character ( len =* )) if ( o /= \"Hi\" ) stop \"Wrong element, q%top() /= 'Hi'\" class default stop \"wrong class in the queue!\" end select call q % pop () o => q % top () select type ( o ) type is ( integer ) if ( o /= 42 ) stop \"Wrong element, q%top() /= 42\" class default stop \"wrong class in the queue!\" end select call q % pop () o => q % top () select type ( o ) type is ( real ( kind ( 0. d0 ))) if ( o /= 3.14 d0 ) stop \"Wrong element, q%top() /= 3.14\" class default stop \"wrong class in the queue!\" end select call q % pop () end subroutine generic_queue_test subroutine check_array ( iter , array ) class ( iterator ) :: iter integer , intent ( in ) :: array (:) class ( * ), pointer :: o integer :: i i = 0 do while ( iter % has_next ()) o => iter % next () i = i + 1 select type ( o ) type is ( integer ) if ( o /= array ( i )) stop \"wrong data in the list\" class default stop \"wrong data type in the list\" end select end do end subroutine check_array end subroutine queues_test end module queues","tags":"","loc":"sourcefile/queues.f90.html","title":"queues.F90 – ooflib"},{"text":"Source Code program ooflib_test use array_iterators , only : array_iterators_test use lists , only : lists_test use queues , only : queues_test use rationals , only : rationals_test call array_iterators_test () call lists_test () call queues_test () call rationals_test () end program ooflib_test","tags":"","loc":"sourcefile/ooflib_test.f90.html","title":"ooflib_test.F90 – ooflib"},{"text":"Source Code !====================================================================== ! !          Copyright Jiri Furst 2013 ! Distributed under the Boost Software License, Version 1.0. !    (See accompanying file LICENSE_1_0.txt or copy at !          http://www.boost.org/LICENSE_1_0.txt) ! !---------------------------------------------------------------------- ! !  MODULE: array_iterators ! !> @author Jiri Furst ! !  DESCRIPTION: !> The module defines iterators for rank-1 arrays ! !====================================================================== module array_iterators use iterators private !> The iterator over an array !> @extends iterators::iterator type , public , extends ( iterator ) :: array_iterator private integer :: idx class ( * ), pointer :: array (:) => null () contains procedure :: has_next => ai_has_next procedure :: next => ai_next end type array_iterator public :: forward_array_iterator public :: reverse_array_iterator public :: array_iterators_test contains !> Creates an iterator going an array in ascending index order !! !! \\param [in] array    - the rank-1 array !! \\result the iterator ! function forward_array_iterator ( array ) result ( it ) class ( * ), target :: array (:) type ( array_iterator ) :: it it % array => array (:) it % idx = lbound ( it % array , 1 ) end function forward_array_iterator !> Creates an iterator going an array in descending index order !! !! \\param [in] array    - the rank-1 array !! \\result the iterator ! function reverse_array_iterator ( array ) result ( it ) class ( * ), target :: array (:) type ( array_iterator ) :: it it % array => array ( :: - 1 ) it % idx = lbound ( it % array , 1 ) end function reverse_array_iterator function ai_has_next ( self ) class ( array_iterator ), intent ( in ) :: self logical :: ai_has_next ai_has_next = self % idx <= ubound ( self % array , 1 ) end function ai_has_next function ai_next ( self ) class ( array_iterator ), intent ( inout ) :: self class ( * ), pointer :: ai_next ai_next => self % array ( self % idx ) self % idx = self % idx + 1 end function ai_next !====================================================================== ! test ! !> Simple test for array iterators ! subroutine array_iterators_test real :: x ( - 1 : 8 ) = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] integer :: i ( 5 ) = [ 4 , 5 , 6 , 7 , 8 ] print * , \"Array iterator tests:\" call forward_iterator_real ( forward_array_iterator ( x ), x ) call forward_iterator_int ( forward_array_iterator ( i ), i ) call reverse_iterator_real ( reverse_array_iterator ( x ), x ) print * contains subroutine forward_iterator_real ( it , z ) class ( iterator ) :: it real :: z (:) class ( * ), pointer :: v integer :: i print * , \" - checking forward iterator (real)\" i = lbound ( z , 1 ) - 1 do while ( it % has_next ()) v => it % next () i = i + 1 select type ( v ) type is ( real ) if ( v /= z ( i )) stop \"error in forward_iterator\" class default stop \"UNKNOWN CLASS in forward_iterator\" end select end do end subroutine forward_iterator_real subroutine forward_iterator_int ( it , z ) class ( iterator ) :: it integer :: z (:) class ( * ), pointer :: v integer :: i print * , \" - checking forward iterator (integer)\" i = lbound ( z , 1 ) - 1 do while ( it % has_next ()) v => it % next () i = i + 1 select type ( v ) type is ( integer ) if ( v /= z ( i )) stop \"error in forward_iterator\" class default stop \"UNKNOWN CLASS in forward_iterator\" end select end do end subroutine forward_iterator_int subroutine reverse_iterator_real ( it , z ) class ( iterator ) :: it real :: z (:) class ( * ), pointer :: v integer :: i print * , \" - checking reverse iterator (real)\" i = ubound ( z , 1 ) + 1 do while ( it % has_next ()) v => it % next () i = i - 1 select type ( v ) type is ( real ) if ( v /= z ( i )) stop \"error in reverse_iterator\" class default stop \"UNKNOWN CLASS in reverse_iterator\" end select end do end subroutine reverse_iterator_real end subroutine array_iterators_test end module array_iterators","tags":"","loc":"sourcefile/array_iterators.f90.html","title":"array_iterators.F90 – ooflib"},{"text":"Source Code !====================================================================== ! !          Copyright Jiri Furst 2013 ! Distributed under the Boost Software License, Version 1.0. !    (See accompanying file LICENSE_1_0.txt or copy at !          http://www.boost.org/LICENSE_1_0.txt) ! !---------------------------------------------------------------------- ! !  MODULE: collections ! !> @author Jiri Furst ! !  DESCRIPTION: !> The module defines abstract collections ! !====================================================================== module collections use objects use iterators implicit none private !====================================================================== !> Abstract collection !! !! The root of collection hierarchy. A collection represents a group !! of elements and provides some basic operations with the elements and !! collections !! type , abstract , extends ( object ), public :: collection contains !> Returns the number of elements in this collection !> \\result number of elements procedure ( coll_size ), deferred , public :: size !> Test if the collection is empty !> \\result `.true.` if the collection is empty procedure , public :: is_empty !> Adds an element to the collection procedure ( coll_add ), deferred , public :: add !> Returns an iterator !> \\result an iterator, `class(iterator), allocatable` procedure ( coll_iterator ), deferred , public :: iterator !> Removes given object !! !! \\param[in] o the object to be removed procedure , public :: remove !> Clears the collections procedure , public :: clear => coll_clear end type collection abstract interface integer function coll_size ( self ) import collection class ( collection ), intent ( in ) :: self end function coll_size !> Interface for collection::add !> \\param[in] o - the object to add subroutine coll_add ( self , o ) import collection class ( collection ), intent ( inout ) :: self class ( * ), intent ( in ) :: o end subroutine coll_add !> Interface for collection::add !> \\param[in] o - the object to add function coll_iterator ( self ) use iterators import collection class ( collection ), target , intent ( in ) :: self class ( iterator ), allocatable :: coll_iterator end function coll_iterator end interface contains logical function is_empty ( self ) class ( collection ), intent ( in ) :: self is_empty = ( self % size () == 0 ) end function is_empty subroutine coll_clear ( self ) class ( collection ), intent ( inout ) :: self class ( iterator ), allocatable :: iter class ( * ), pointer :: o allocate ( iter , source = self % iterator ()) do while ( iter % has_next ()) o => iter % next () call iter % remove () end do end subroutine coll_clear subroutine remove ( self , o , stat ) class ( collection ), intent ( inout ) :: self !< the collection class ( object ), intent ( in ) :: o !< the object to be removed integer , optional , intent ( out ) :: stat !< 0 if removal was succesfull class ( iterator ), allocatable :: iter class ( * ), pointer :: p allocate ( iter , source = self % iterator ()) do while ( iter % has_next ()) p => iter % next () if ( o == p ) then call iter % remove () if ( present ( stat )) stat = 0 return end if end do if ( present ( stat )) stat = 1 end subroutine remove end module collections","tags":"","loc":"sourcefile/collections.f90.html","title":"collections.F90 – ooflib"},{"text":"Source Code !====================================================================== ! !          Copyright Jiri Furst 2013 ! Distributed under the Boost Software License, Version 1.0. !    (See accompanying file LICENSE_1_0.txt or copy at !          http://www.boost.org/LICENSE_1_0.txt) ! !---------------------------------------------------------------------- ! !  MODULE: iterators ! !> @author Jiri Furst ! !  DESCRIPTION: !> The module defines an abstract class iterator ! !====================================================================== module iterators use objects private !====================================================================== !> Abstract iterator !! !! The class iterator is an abstract iterator designed in the style of !! Java Iterator. !! !! The iterator should be able to iterate over an collection using !! following idiom: !! !! @code{.f90} !! !! class(iterator), allocatable :: iter !! class(*), pointer :: d !! allocate(iter, source=collection%iterator()) !! !! do while (iter%has_next()) !!   d => iter%next() !!   operate on d !! end do !! !! @endcode type , abstract , extends ( object ), public :: iterator contains !> Returns `.true.` if the iterator has more elements. !> @return `.true.` if the iterator has more elements. procedure ( iterator_has_next ), deferred :: has_next !> Returns the pointer to next element !> @return the pointer to next element procedure ( iterator_next ), deferred :: next !> Removes from the underlying collection the last element !> returned by the iterator procedure :: remove end type iterator abstract interface function iterator_next ( self ) import iterator class ( iterator ), intent ( inout ) :: self class ( * ), pointer :: iterator_next end function iterator_next function iterator_has_next ( self ) import iterator class ( iterator ), intent ( in ) :: self logical :: iterator_has_next end function iterator_has_next end interface contains subroutine remove ( self ) class ( iterator ), intent ( inout ) :: self stop \"iterator:remove has to be overridden\" end subroutine remove end module iterators","tags":"","loc":"sourcefile/iterators.f90.html","title":"iterators.F90 – ooflib"},{"text":"Source Code !====================================================================== ! !          Copyright Jiri Furst 2013 ! Distributed under the Boost Software License, Version 1.0. !    (See accompanying file LICENSE_1_0.txt or copy at !          http://www.boost.org/LICENSE_1_0.txt) ! !---------------------------------------------------------------------- ! !  MODULE: objects ! !  @author Jiri Furst ! !  DESCRIPTION: ! ! !====================================================================== module objects !! author: Jiri Furst !! !! The module defines class object which is a root of the class hierarchy private type , public :: object !! The root of class hierarchy contains generic :: operator ( == ) => equals !! Compares with other object procedure :: equals end type object contains logical function equals ( self , o ) !! Default equals method class ( object ), intent ( in ) :: self !! this object class ( * ), intent ( in ) :: o !! other object equals = .false. end function equals end module objects","tags":"","loc":"sourcefile/objects.f90.html","title":"objects.F90 – ooflib"},{"text":"Source Code !====================================================================== ! !          Copyright Jiri Furst 2013 ! Distributed under the Boost Software License, Version 1.0. !    (See accompanying file LICENSE_1_0.txt or copy at !          http://www.boost.org/LICENSE_1_0.txt) ! !---------------------------------------------------------------------- ! !  MODULE: rationals ! !> @author Jiri Furst ! !  DESCRIPTION: !> The module implements oprations with rational numbers ! !====================================================================== module rationals private type , public :: rational integer :: numerator = 0 integer :: denominator = 1 end type interface real module procedure real_rat end interface public :: real interface assignment ( = ) module procedure assign_int end interface interface operator ( + ) module procedure add_rat_rat module procedure add_int_rat module procedure add_rat_int end interface public :: operator ( + ) interface operator ( - ) module procedure sub_rat_rat module procedure sub_int_rat module procedure sub_rat_int end interface public :: operator ( - ) interface operator ( * ) module procedure mul_rat_rat module procedure mul_int_rat module procedure mul_rat_int end interface public :: operator ( * ) interface operator ( / ) module procedure div_rat_rat module procedure div_rat_int module procedure div_int_rat end interface public :: operator ( / ) public :: rationals_test contains function real_rat ( rat ) type ( rational ), intent ( in ) :: rat integer , parameter :: dbl = selected_real_kind ( 15 ) real ( dbl ) :: real_rat real_rat = rat % numerator / real ( rat % denominator , dbl ) end function real_rat subroutine assign_int ( c , a ) integer , intent ( in ) :: a type ( rational ), intent ( out ) :: c c = rational ( a , 1 ) end subroutine assign_int !---------------------------------------------------------------------- function add_rat_rat ( a , b ) result ( c ) type ( rational ), intent ( in ) :: a , b type ( rational ) :: c c % numerator = a % numerator * b % denominator + a % denominator * b % numerator c % denominator = a % denominator * b % denominator call normalize ( c ) end function add_rat_rat function add_rat_int ( a , b ) result ( c ) type ( rational ), intent ( in ) :: a integer , intent ( in ) :: b type ( rational ) :: c c = a c % numerator = c % numerator + b * c % denominator end function add_rat_int function add_int_rat ( b , a ) result ( c ) type ( rational ), intent ( in ) :: a integer , intent ( in ) :: b type ( rational ) :: c c = a c % numerator = c % numerator + b * c % denominator end function add_int_rat !---------------------------------------------------------------------- function sub_rat_rat ( a , b ) result ( c ) type ( rational ), intent ( in ) :: a , b type ( rational ) :: c integer :: denom c % numerator = a % numerator * b % denominator - a % denominator * b % numerator c % denominator = a % denominator * b % denominator call normalize ( c ) end function sub_rat_rat function sub_int_rat ( b , a ) result ( c ) type ( rational ), intent ( in ) :: a integer , intent ( in ) :: b type ( rational ) :: c c % numerator = b * a % denominator - a % numerator c % denominator = a % denominator end function sub_int_rat function sub_rat_int ( a , b ) result ( c ) type ( rational ), intent ( in ) :: a integer , intent ( in ) :: b type ( rational ) :: c c % numerator = a % numerator - b * a % denominator c % denominator = a % denominator end function sub_rat_int !---------------------------------------------------------------------- function mul_rat_rat ( a , b ) result ( c ) type ( rational ), intent ( in ) :: a , b type ( rational ) :: c c % numerator = a % numerator * b % numerator c % denominator = a % denominator * b % denominator call normalize ( c ) end function mul_rat_rat function mul_rat_int ( a , b ) result ( c ) type ( rational ), intent ( in ) :: a integer , intent ( in ) :: b type ( rational ) :: c c % numerator = a % numerator * b c % denominator = a % denominator call normalize ( c ) end function mul_rat_int function mul_int_rat ( b , a ) result ( c ) type ( rational ), intent ( in ) :: a integer , intent ( in ) :: b type ( rational ) :: c c % numerator = a % numerator * b c % denominator = a % denominator call normalize ( c ) end function mul_int_rat !---------------------------------------------------------------------- function div_rat_rat ( a , b ) result ( c ) type ( rational ), intent ( in ) :: a , b type ( rational ) :: c integer :: denom c % numerator = a % numerator * b % denominator c % denominator = a % denominator * b % numerator call normalize ( c ) end function div_rat_rat function div_rat_int ( a , b ) result ( c ) type ( rational ), intent ( in ) :: a integer , intent ( in ) :: b type ( rational ) :: c c % numerator = a % numerator c % denominator = a % denominator * b call normalize ( c ) end function div_rat_int function div_int_rat ( b , a ) result ( c ) type ( rational ), intent ( in ) :: a integer , intent ( in ) :: b type ( rational ) :: c c % numerator = b * a % denominator c % denominator = a % numerator call normalize ( c ) end function div_int_rat !====================================================================== subroutine normalize ( rat ) type ( rational ), intent ( inout ) :: rat integer :: gcd if ( rat % denominator < 0 ) then rat % numerator = - rat % numerator rat % denominator = - rat % denominator end if gcd = greatest_common_divisor ( rat % numerator , rat % denominator ) rat % numerator = rat % numerator / gcd rat % denominator = rat % denominator / gcd end subroutine normalize function greatest_common_divisor ( x , y ) integer , intent ( in ) :: x , y integer :: greatest_common_divisor integer :: a , b a = abs ( x ) b = abs ( y ) do while ( a /= b ) if ( a > b ) then a = a - b else b = b - a end if end do greatest_common_divisor = a end function greatest_common_divisor !====================================================================== subroutine rationals_test () print * , \"Rationals tests:\" call rationals_constructors () call rationals_operators () contains subroutine rationals_constructors () type ( rational ) :: a , b , c print * , \" - constructors\" a = rational ( 2 , 3 ) if ( abs ( real ( a ) - 0.666 ) > 0.001 ) stop \"error in rational(2,3)\" b = 2 if ( abs ( real ( b ) - 2 ) > 0.001 ) stop \"error in b = 2\" c = a if ( abs ( real ( c ) - 0.666 ) > 0.001 ) stop \"error in c = a\" end subroutine rationals_constructors subroutine rationals_operators () type ( rational ) :: a , b , c , d print * , \" - operators\" a = rational ( 1 , 2 ) b = rational ( 3 , 8 ) c = rational ( 4 , 3 ) d = a + b if ( d % numerator /= 7 .or. d % denominator /= 8 ) & stop \"error in 1/2 + 3/8\" d = b - a if ( d % numerator /= - 1 .or. d % denominator /= 8 ) & stop \"error in 1/2 - 3/8\" d = ( a + b ) + ( a - b ) if ( d % numerator /= 1 .or. d % denominator /= 1 ) & stop \"error in (1/2+b) - (1/2-b)\" d = a * b if ( d % numerator /= 3 .or. d % denominator /= 16 ) & stop \"error in 1/2 * 3/8\" d = a / b if ( d % numerator /= 4 .or. d % denominator /= 3 ) & stop \"error in (1/2) / (3/8)\" d = 2 * a if ( d % numerator /= 1 .or. d % denominator /= 1 ) & stop \"error in 2 * (1/2)\" d = b * 4 if ( d % numerator /= 3 .or. d % denominator /= 2 ) & stop \"error in (3/8) * 4\" d = 2 / a if ( d % numerator /= 4 .or. d % denominator /= 1 ) & stop \"error in 2 / (1/2)\" d = b / 4 if ( d % numerator /= 3 .or. d % denominator /= 32 ) & stop \"error in (3/8) / 4\" end subroutine rationals_operators end subroutine rationals_test end module rationals","tags":"","loc":"sourcefile/rationals.f90.html","title":"rationals.F90 – ooflib"},{"text":"Source Code !====================================================================== ! !          Copyright Jiri Furst 2013 ! Distributed under the Boost Software License, Version 1.0. !    (See accompanying file LICENSE_1_0.txt or copy at !          http://www.boost.org/LICENSE_1_0.txt) ! !---------------------------------------------------------------------- ! !  MODULE: lists ! !> @author Jiri Furst ! !  DESCRIPTION: !> The module defines single linked list of generic objects ! !====================================================================== module lists use objects use iterators use collections private type , extends ( object ) :: list_item class ( list_item ), pointer :: next => null () class ( * ), allocatable :: val end type list_item !> The single linked list of generic objects !! type , public , extends ( collection ) :: list private integer :: size_ = 0 type ( list_item ) :: first_ptr !< pointer to first item type ( list_item ) :: last_ptr !< pointer to last item contains procedure , public :: size => lst_size procedure , public :: add => lst_add procedure , public :: iterator => lst_iterator end type list type , public , extends ( iterator ) :: list_iterator private class ( list ), pointer :: parent => null () class ( list_item ), pointer :: item => null () class ( list_item ), pointer :: last => null () contains procedure , public :: has_next => li_has_next procedure , public :: next => li_next procedure , public :: remove => li_remove end type list_iterator public :: lists_test contains integer function lst_size ( self ) class ( list ), intent ( in ) :: self lst_size = self % size_ end function lst_size subroutine lst_add ( self , o ) class ( list ), intent ( inout ) :: self class ( * ), intent ( in ) :: o type ( list_item ), pointer :: item allocate ( item ) allocate ( item % val , source = o ) if ( self % is_empty () ) then self % first_ptr % next => item else self % last_ptr % next % next => item end if self % last_ptr % next => item self % size_ = self % size_ + 1 end subroutine lst_add function lst_iterator ( self ) class ( list ), target , intent ( in ) :: self class ( iterator ), allocatable :: lst_iterator allocate ( list_iterator :: lst_iterator ) select type ( lst_iterator ) type is ( list_iterator ) lst_iterator % parent => self lst_iterator % item => self % first_ptr end select end function lst_iterator !====================================================================== ! list_iterator !====================================================================== logical function li_has_next ( self ) class ( list_iterator ), intent ( in ) :: self li_has_next = associated ( self % item % next ) end function li_has_next function li_next ( self ) class ( list_iterator ), intent ( inout ) :: self class ( * ), pointer :: li_next self % last => self % item self % item => self % item % next li_next => self % item % val end function li_next subroutine li_remove ( self ) class ( list_iterator ), intent ( inout ) :: self class ( list_item ), pointer :: tmp if ( .not. associated ( self % last )) stop \"Error in list_iterator::remove\" self % last % next => self % item % next self % parent % size_ = self % parent % size_ - 1 tmp => self % item self % item => self % last deallocate ( tmp ) end subroutine li_remove !====================================================================== ! TEST !====================================================================== subroutine lists_test print * , \"Homogeneous iterator tests:\" call integer_list_test () print * contains subroutine integer_list_test () type ( list ) :: l class ( iterator ), allocatable :: iter integer :: i class ( * ), pointer :: o print * , \" - checking homogeneous integer list\" if ( l % size () /= 0 ) stop \"empty list size /= 0!\" call l % add ( 1 ) call l % add ( 2 ) call l % add ( 3 ) if ( l % size () /= 3 ) stop \"short list size /= 3!\" call check_array ( l % iterator (), [ 1 , 2 , 3 ] ) call l % clear () if ( l % size () /= 0 ) stop \"empty list size /= 0!\" call l % add ( 2 ) call l % add ( 3 ) call l % add ( 4 ) call check_array ( l % iterator (), [ 2 , 3 , 4 ] ) allocate ( iter , source = l % iterator ()) o => iter % next () ! Points to 2 o => iter % next () ! Points to 4 call iter % remove () if ( l % size () /= 2 ) stop \"short list size /= 2!\" deallocate ( iter ) call check_array ( l % iterator (), [ 2 , 4 ] ) call l % clear () end subroutine integer_list_test subroutine check_array ( iter , array ) class ( iterator ) :: iter integer , intent ( in ) :: array (:) class ( * ), pointer :: o integer :: i i = 0 do while ( iter % has_next ()) o => iter % next () i = i + 1 select type ( o ) type is ( integer ) if ( o /= array ( i )) stop \"wrong data in the list\" class default stop \"wrong data type in the list\" end select end do end subroutine check_array end subroutine lists_test end module lists","tags":"","loc":"sourcefile/lists.f90.html","title":"lists.F90 – ooflib"},{"text":"The simple queue Components Type Visibility Attributes Name Initial type( list ), private :: container Type-Bound Procedures procedure, public :: is_empty private  function is_empty (self) Arguments Type Intent Optional Attributes Name class( queue ), intent(in) :: self Return Value logical procedure, public :: size private  function size (self) Arguments Type Intent Optional Attributes Name class( queue ), intent(in) :: self Return Value integer procedure, public :: push private  subroutine push (self, o) Arguments Type Intent Optional Attributes Name class( queue ), intent(inout) :: self class(*), intent(in) :: o procedure, public :: add private  subroutine add (self, o) Arguments Type Intent Optional Attributes Name class( queue ), intent(inout) :: self class(*), intent(in) :: o procedure, public :: top private  function top (self) Arguments Type Intent Optional Attributes Name class( queue ), intent(inout) :: self Return Value class(*),\n  pointer procedure, public :: pop private  subroutine pop (self) Arguments Type Intent Optional Attributes Name class( queue ), intent(inout) :: self procedure, public :: clear private  subroutine clear (self) Arguments Type Intent Optional Attributes Name class( queue ), intent(inout) :: self procedure, public :: iterator => q_iterator private  function q_iterator (self) Arguments Type Intent Optional Attributes Name class( queue ), intent(in), target :: self Return Value class( iterator ),\n  allocatable","tags":"","loc":"type/queue.html","title":"queue – ooflib "},{"text":"The iterator over an array\n @extends iterators::iterator Components Type Visibility Attributes Name Initial integer, private :: idx class(*), private, pointer :: array (:) => null() Type-Bound Procedures procedure, public :: has_next => ai_has_next private  function ai_has_next (self) Arguments Type Intent Optional Attributes Name class( array_iterator ), intent(in) :: self Return Value logical procedure, public :: next => ai_next private  function ai_next (self) Arguments Type Intent Optional Attributes Name class( array_iterator ), intent(inout) :: self Return Value class(*),\n  pointer","tags":"","loc":"type/array_iterator.html","title":"array_iterator – ooflib "},{"text":"Abstract collection The root of collection hierarchy. A collection represents a group\n of elements and provides some basic operations with the elements and \n collections Type-Bound Procedures procedure, public, deferred :: size => size Returns the number of elements in this collection\n \\result number of elements size() Arguments None procedure, public :: is_empty Test if the collection is empty\n \\result .true. if the collection is empty private  function is_empty (self) Arguments Type Intent Optional Attributes Name class( collection ), intent(in) :: self Return Value logical procedure, public, deferred :: add => add Adds an element to the collection add() Arguments None procedure, public, deferred :: iterator => iterator Returns an iterator\n \\result an iterator, class(iterator), allocatable iterator() Arguments None procedure, public :: remove Removes given object private  subroutine remove (self, o, stat) Arguments Type Intent Optional Attributes Name class( collection ), intent(inout) :: self class( object ), intent(in) :: o integer, intent(out), optional :: stat procedure, public :: clear => coll_clear Clears the collections private  subroutine coll_clear (self) Arguments Type Intent Optional Attributes Name class( collection ), intent(inout) :: self","tags":"","loc":"type/collection.html","title":"collection – ooflib "},{"text":"Abstract iterator The class iterator is an abstract iterator designed in the style of \n Java Iterator. The iterator should be able to iterate over an collection using\n following idiom: @code{.f90} class(iterator), allocatable :: iter\n class(*), pointer :: d\n allocate(iter, source=collection%iterator()) do while (iter%has_next())\n   d => iter%next()\n   operate on d end do @endcode Type-Bound Procedures procedure, public, deferred :: has_next => has_next Returns .true. if the iterator has more elements.\n @return .true. if the iterator has more elements. has_next() Arguments None procedure, public, deferred :: next => next Returns the pointer to next element\n @return the pointer to next element next() Arguments None procedure, public :: remove Removes from the underlying collection the last element\n returned by the iterator private  subroutine remove (self) Arguments Type Intent Optional Attributes Name class( iterator ), intent(inout) :: self","tags":"","loc":"type/iterator.html","title":"iterator – ooflib "},{"text":"The root of class hierarchy Type-Bound Procedures generic, public :: operator(==) => equals Compares with other object private  function equals (self, o) Arguments Type Intent Optional Attributes Name class( object ), intent(in) :: self this object class(*), intent(in) :: o other object Return Value logical Description Default equals method procedure, public :: equals private  function equals (self, o) Arguments Type Intent Optional Attributes Name class( object ), intent(in) :: self this object class(*), intent(in) :: o other object Return Value logical Description Default equals method","tags":"","loc":"type/object.html","title":"object – ooflib "},{"text":"Components Type Visibility Attributes Name Initial integer, public :: numerator = 0 integer, public :: denominator = 1","tags":"","loc":"type/rational.html","title":"rational – ooflib "},{"text":"Components Type Visibility Attributes Name Initial class( list_item ), public, pointer :: next => null() class(*), public, allocatable :: val","tags":"","loc":"type/list_item.html","title":"list_item – ooflib "},{"text":"The single linked list of generic objects Components Type Visibility Attributes Name Initial integer, private :: size_ = 0 type( list_item ), private :: first_ptr type( list_item ), private :: last_ptr Type-Bound Procedures procedure, public :: size => lst_size private  function lst_size (self) Arguments Type Intent Optional Attributes Name class( list ), intent(in) :: self Return Value integer procedure, public :: add => lst_add private  subroutine lst_add (self, o) Arguments Type Intent Optional Attributes Name class( list ), intent(inout) :: self class(*), intent(in) :: o procedure, public :: iterator => lst_iterator private  function lst_iterator (self) Arguments Type Intent Optional Attributes Name class( list ), intent(in), target :: self Return Value class( iterator ),\n  allocatable","tags":"","loc":"type/list.html","title":"list – ooflib "},{"text":"Components Type Visibility Attributes Name Initial class( list ), private, pointer :: parent => null() class( list_item ), private, pointer :: item => null() class( list_item ), private, pointer :: last => null() Type-Bound Procedures procedure, public :: has_next => li_has_next private  function li_has_next (self) Arguments Type Intent Optional Attributes Name class( list_iterator ), intent(in) :: self Return Value logical procedure, public :: next => li_next private  function li_next (self) Arguments Type Intent Optional Attributes Name class( list_iterator ), intent(inout) :: self Return Value class(*),\n  pointer procedure, public :: remove => li_remove private  subroutine li_remove (self) Arguments Type Intent Optional Attributes Name class( list_iterator ), intent(inout) :: self","tags":"","loc":"type/list_iterator.html","title":"list_iterator – ooflib "},{"text":"abstract interface private  subroutine coll_add(self, o) Arguments Type Intent Optional Attributes Name class( collection ), intent(inout) :: self class(*), intent(in) :: o Description Interface for collection::add\n \\param[in] o - the object to add","tags":"","loc":"interface/coll_add.html","title":"coll_add – ooflib"},{"text":"abstract interface private  function coll_size(self) Arguments Type Intent Optional Attributes Name class( collection ), intent(in) :: self Return Value integer","tags":"","loc":"interface/coll_size.html","title":"coll_size – ooflib"},{"text":"abstract interface private  function coll_iterator(self) Uses: iterators Arguments Type Intent Optional Attributes Name class( collection ), intent(in), target :: self Return Value class([ , '']),\n    allocatable Description Interface for collection::add\n \\param[in] o - the object to add","tags":"","loc":"interface/coll_iterator.html","title":"coll_iterator – ooflib"},{"text":"abstract interface private  function iterator_next(self) Arguments Type Intent Optional Attributes Name class( iterator ), intent(inout) :: self Return Value class(['*', '']),\n    pointer","tags":"","loc":"interface/iterator_next.html","title":"iterator_next – ooflib"},{"text":"abstract interface private  function iterator_has_next(self) Arguments Type Intent Optional Attributes Name class( iterator ), intent(in) :: self Return Value logical","tags":"","loc":"interface/iterator_has_next.html","title":"iterator_has_next – ooflib"},{"text":"private  function is_empty(self) Arguments Type Intent Optional Attributes Name class( queue ), intent(in) :: self Return Value logical","tags":"","loc":"proc/is_empty.html","title":"is_empty – ooflib"},{"text":"private  function size(self) Arguments Type Intent Optional Attributes Name class( queue ), intent(in) :: self Return Value integer","tags":"","loc":"proc/size.html","title":"size – ooflib"},{"text":"private  function q_iterator(self) Arguments Type Intent Optional Attributes Name class( queue ), intent(in), target :: self Return Value class([ , '']),\n    allocatable","tags":"","loc":"proc/q_iterator.html","title":"q_iterator – ooflib"},{"text":"private  function top(self) Arguments Type Intent Optional Attributes Name class( queue ), intent(inout) :: self Return Value class(['*', '']),\n    pointer Variables Type Visibility Attributes Name Initial class( iterator ), public, allocatable :: iter","tags":"","loc":"proc/top.html","title":"top – ooflib"},{"text":"private  subroutine clear(self) Arguments Type Intent Optional Attributes Name class( queue ), intent(inout) :: self","tags":"","loc":"proc/clear.html","title":"clear – ooflib"},{"text":"private  subroutine push(self, o) Arguments Type Intent Optional Attributes Name class( queue ), intent(inout) :: self class(*), intent(in) :: o","tags":"","loc":"proc/push.html","title":"push – ooflib"},{"text":"private  subroutine add(self, o) Arguments Type Intent Optional Attributes Name class( queue ), intent(inout) :: self class(*), intent(in) :: o","tags":"","loc":"proc/add.html","title":"add – ooflib"},{"text":"private  subroutine pop(self) Arguments Type Intent Optional Attributes Name class( queue ), intent(inout) :: self Variables Type Visibility Attributes Name Initial class( iterator ), public, allocatable :: iter class(*), public, pointer :: top","tags":"","loc":"proc/pop.html","title":"pop – ooflib"},{"text":"public  subroutine queues_test() Arguments None Subroutines subroutine integer_queue_test() Arguments None subroutine generic_queue_test() Arguments None subroutine check_array(iter, array) Arguments Type Intent Optional Attributes Name class( iterator ), intent(inout) :: iter integer, intent(in) :: array (:)","tags":"","loc":"proc/queues_test.html","title":"queues_test – ooflib"},{"text":"public  function forward_array_iterator(array) Arguments Type Intent Optional Attributes Name class(*), intent(inout), target :: array (:) Return Value type([ , '']) Description Creates an iterator going an array in ascending index order \\param [in] array    - the rank-1 array\n \\result the iterator","tags":"","loc":"proc/forward_array_iterator.html","title":"forward_array_iterator – ooflib"},{"text":"public  function reverse_array_iterator(array) Arguments Type Intent Optional Attributes Name class(*), intent(inout), target :: array (:) Return Value type([ , '']) Description Creates an iterator going an array in descending index order \\param [in] array    - the rank-1 array\n \\result the iterator","tags":"","loc":"proc/reverse_array_iterator.html","title":"reverse_array_iterator – ooflib"},{"text":"private  function ai_has_next(self) Arguments Type Intent Optional Attributes Name class( array_iterator ), intent(in) :: self Return Value logical","tags":"","loc":"proc/ai_has_next.html","title":"ai_has_next – ooflib"},{"text":"private  function ai_next(self) Arguments Type Intent Optional Attributes Name class( array_iterator ), intent(inout) :: self Return Value class(['*', '']),\n    pointer","tags":"","loc":"proc/ai_next.html","title":"ai_next – ooflib"},{"text":"public  subroutine array_iterators_test() Arguments None Description Simple test for array iterators Variables Type Visibility Attributes Name Initial real, public :: x (-1:8) = [1,2,3,4,5,6,7,8,9,10] integer, public :: i (5) = [4,5,6,7,8] Subroutines subroutine forward_iterator_real(it, z) Arguments Type Intent Optional Attributes Name class( iterator ), intent(inout) :: it real, intent(inout) :: z (:) subroutine forward_iterator_int(it, z) Arguments Type Intent Optional Attributes Name class( iterator ), intent(inout) :: it integer, intent(inout) :: z (:) subroutine reverse_iterator_real(it, z) Arguments Type Intent Optional Attributes Name class( iterator ), intent(inout) :: it real, intent(inout) :: z (:)","tags":"","loc":"proc/array_iterators_test.html","title":"array_iterators_test – ooflib"},{"text":"private  function is_empty(self) Arguments Type Intent Optional Attributes Name class( collection ), intent(in) :: self Return Value logical","tags":"","loc":"proc/is_empty.html","title":"is_empty – ooflib"},{"text":"private  subroutine coll_clear(self) Arguments Type Intent Optional Attributes Name class( collection ), intent(inout) :: self Variables Type Visibility Attributes Name Initial class( iterator ), public, allocatable :: iter class(*), public, pointer :: o","tags":"","loc":"proc/coll_clear.html","title":"coll_clear – ooflib"},{"text":"private  subroutine remove(self, o, stat) Arguments Type Intent Optional Attributes Name class( collection ), intent(inout) :: self class( object ), intent(in) :: o integer, intent(out), optional :: stat Variables Type Visibility Attributes Name Initial class( iterator ), public, allocatable :: iter class(*), public, pointer :: p","tags":"","loc":"proc/remove.html","title":"remove – ooflib"},{"text":"private  subroutine remove(self) Arguments Type Intent Optional Attributes Name class( iterator ), intent(inout) :: self","tags":"","loc":"proc/remove.html","title":"remove – ooflib"},{"text":"private  function equals(self, o) Arguments Type Intent Optional Attributes Name class( object ), intent(in) :: self this object class(*), intent(in) :: o other object Return Value logical Description Default equals method","tags":"","loc":"proc/equals.html","title":"equals – ooflib"},{"text":"private  function real_rat(rat) Arguments Type Intent Optional Attributes Name type( rational ), intent(in) :: rat Return Value real(kind=dbl) Variables Type Visibility Attributes Name Initial integer, public, parameter :: dbl = selected_real_kind(15)","tags":"","loc":"proc/real_rat.html","title":"real_rat – ooflib"},{"text":"private  function add_rat_rat(a, b) Arguments Type Intent Optional Attributes Name type( rational ), intent(in) :: a type( rational ), intent(in) :: b Return Value type([ , ''])","tags":"","loc":"proc/add_rat_rat.html","title":"add_rat_rat – ooflib"},{"text":"private  function add_rat_int(a, b) Arguments Type Intent Optional Attributes Name type( rational ), intent(in) :: a integer, intent(in) :: b Return Value type([ , ''])","tags":"","loc":"proc/add_rat_int.html","title":"add_rat_int – ooflib"},{"text":"private  function add_int_rat(b, a) Arguments Type Intent Optional Attributes Name integer, intent(in) :: b type( rational ), intent(in) :: a Return Value type([ , ''])","tags":"","loc":"proc/add_int_rat.html","title":"add_int_rat – ooflib"},{"text":"private  function sub_rat_rat(a, b) Arguments Type Intent Optional Attributes Name type( rational ), intent(in) :: a type( rational ), intent(in) :: b Return Value type([ , '']) Variables Type Visibility Attributes Name Initial integer, public :: denom","tags":"","loc":"proc/sub_rat_rat.html","title":"sub_rat_rat – ooflib"},{"text":"private  function sub_int_rat(b, a) Arguments Type Intent Optional Attributes Name integer, intent(in) :: b type( rational ), intent(in) :: a Return Value type([ , ''])","tags":"","loc":"proc/sub_int_rat.html","title":"sub_int_rat – ooflib"},{"text":"private  function sub_rat_int(a, b) Arguments Type Intent Optional Attributes Name type( rational ), intent(in) :: a integer, intent(in) :: b Return Value type([ , ''])","tags":"","loc":"proc/sub_rat_int.html","title":"sub_rat_int – ooflib"},{"text":"private  function mul_rat_rat(a, b) Arguments Type Intent Optional Attributes Name type( rational ), intent(in) :: a type( rational ), intent(in) :: b Return Value type([ , ''])","tags":"","loc":"proc/mul_rat_rat.html","title":"mul_rat_rat – ooflib"},{"text":"private  function mul_rat_int(a, b) Arguments Type Intent Optional Attributes Name type( rational ), intent(in) :: a integer, intent(in) :: b Return Value type([ , ''])","tags":"","loc":"proc/mul_rat_int.html","title":"mul_rat_int – ooflib"},{"text":"private  function mul_int_rat(b, a) Arguments Type Intent Optional Attributes Name integer, intent(in) :: b type( rational ), intent(in) :: a Return Value type([ , ''])","tags":"","loc":"proc/mul_int_rat.html","title":"mul_int_rat – ooflib"},{"text":"private  function div_rat_rat(a, b) Arguments Type Intent Optional Attributes Name type( rational ), intent(in) :: a type( rational ), intent(in) :: b Return Value type([ , '']) Variables Type Visibility Attributes Name Initial integer, public :: denom","tags":"","loc":"proc/div_rat_rat.html","title":"div_rat_rat – ooflib"},{"text":"private  function div_rat_int(a, b) Arguments Type Intent Optional Attributes Name type( rational ), intent(in) :: a integer, intent(in) :: b Return Value type([ , ''])","tags":"","loc":"proc/div_rat_int.html","title":"div_rat_int – ooflib"},{"text":"private  function div_int_rat(b, a) Arguments Type Intent Optional Attributes Name integer, intent(in) :: b type( rational ), intent(in) :: a Return Value type([ , ''])","tags":"","loc":"proc/div_int_rat.html","title":"div_int_rat – ooflib"},{"text":"private  function greatest_common_divisor(x, y) Arguments Type Intent Optional Attributes Name integer, intent(in) :: x integer, intent(in) :: y Return Value integer Variables Type Visibility Attributes Name Initial integer, public :: a integer, public :: b","tags":"","loc":"proc/greatest_common_divisor.html","title":"greatest_common_divisor – ooflib"},{"text":"private  subroutine assign_int(c, a) Arguments Type Intent Optional Attributes Name type( rational ), intent(out) :: c integer, intent(in) :: a","tags":"","loc":"proc/assign_int.html","title":"assign_int – ooflib"},{"text":"private  subroutine normalize(rat) Arguments Type Intent Optional Attributes Name type( rational ), intent(inout) :: rat Variables Type Visibility Attributes Name Initial integer, public :: gcd","tags":"","loc":"proc/normalize.html","title":"normalize – ooflib"},{"text":"public  subroutine rationals_test() Arguments None Subroutines subroutine rationals_constructors() Arguments None subroutine rationals_operators() Arguments None","tags":"","loc":"proc/rationals_test.html","title":"rationals_test – ooflib"},{"text":"public interface real Module Procedures private  function real_rat (rat) Arguments Type Intent Optional Attributes Name type( rational ), intent(in) :: rat Return Value real(kind=dbl)","tags":"","loc":"interface/real.html","title":"real – ooflib"},{"text":"private interface assignment(=) Module Procedures private  subroutine assign_int (c, a) Arguments Type Intent Optional Attributes Name type( rational ), intent(out) :: c integer, intent(in) :: a","tags":"","loc":"interface/assignment(=).html","title":"assignment(=) – ooflib"},{"text":"private interface operator(+) Module Procedures private  function add_rat_rat (a, b) Arguments Type Intent Optional Attributes Name type( rational ), intent(in) :: a type( rational ), intent(in) :: b Return Value type( rational ) private  function add_int_rat (b, a) Arguments Type Intent Optional Attributes Name integer, intent(in) :: b type( rational ), intent(in) :: a Return Value type( rational ) private  function add_rat_int (a, b) Arguments Type Intent Optional Attributes Name type( rational ), intent(in) :: a integer, intent(in) :: b Return Value type( rational )","tags":"","loc":"interface/operator(+).html","title":"operator(+) – ooflib"},{"text":"private interface operator(-) Module Procedures private  function sub_rat_rat (a, b) Arguments Type Intent Optional Attributes Name type( rational ), intent(in) :: a type( rational ), intent(in) :: b Return Value type( rational ) private  function sub_int_rat (b, a) Arguments Type Intent Optional Attributes Name integer, intent(in) :: b type( rational ), intent(in) :: a Return Value type( rational ) private  function sub_rat_int (a, b) Arguments Type Intent Optional Attributes Name type( rational ), intent(in) :: a integer, intent(in) :: b Return Value type( rational )","tags":"","loc":"interface/operator(-).html","title":"operator(-) – ooflib"},{"text":"private interface operator(*) Module Procedures private  function mul_rat_rat (a, b) Arguments Type Intent Optional Attributes Name type( rational ), intent(in) :: a type( rational ), intent(in) :: b Return Value type( rational ) private  function mul_int_rat (b, a) Arguments Type Intent Optional Attributes Name integer, intent(in) :: b type( rational ), intent(in) :: a Return Value type( rational ) private  function mul_rat_int (a, b) Arguments Type Intent Optional Attributes Name type( rational ), intent(in) :: a integer, intent(in) :: b Return Value type( rational )","tags":"","loc":"interface/operator(*).html","title":"operator(*) – ooflib"},{"text":"private interface operator(/) Module Procedures private  function div_rat_rat (a, b) Arguments Type Intent Optional Attributes Name type( rational ), intent(in) :: a type( rational ), intent(in) :: b Return Value type( rational ) private  function div_rat_int (a, b) Arguments Type Intent Optional Attributes Name type( rational ), intent(in) :: a integer, intent(in) :: b Return Value type( rational ) private  function div_int_rat (b, a) Arguments Type Intent Optional Attributes Name integer, intent(in) :: b type( rational ), intent(in) :: a Return Value type( rational )","tags":"","loc":"interface/operator(slash).html","title":"operator(/) – ooflib"},{"text":"private  function lst_size(self) Arguments Type Intent Optional Attributes Name class( list ), intent(in) :: self Return Value integer","tags":"","loc":"proc/lst_size.html","title":"lst_size – ooflib"},{"text":"private  function lst_iterator(self) Arguments Type Intent Optional Attributes Name class( list ), intent(in), target :: self Return Value class([ , '']),\n    allocatable","tags":"","loc":"proc/lst_iterator.html","title":"lst_iterator – ooflib"},{"text":"private  function li_has_next(self) Arguments Type Intent Optional Attributes Name class( list_iterator ), intent(in) :: self Return Value logical","tags":"","loc":"proc/li_has_next.html","title":"li_has_next – ooflib"},{"text":"private  function li_next(self) Arguments Type Intent Optional Attributes Name class( list_iterator ), intent(inout) :: self Return Value class(['*', '']),\n    pointer","tags":"","loc":"proc/li_next.html","title":"li_next – ooflib"},{"text":"private  subroutine lst_add(self, o) Arguments Type Intent Optional Attributes Name class( list ), intent(inout) :: self class(*), intent(in) :: o Variables Type Visibility Attributes Name Initial type( list_item ), public, pointer :: item","tags":"","loc":"proc/lst_add.html","title":"lst_add – ooflib"},{"text":"private  subroutine li_remove(self) Arguments Type Intent Optional Attributes Name class( list_iterator ), intent(inout) :: self Variables Type Visibility Attributes Name Initial class( list_item ), public, pointer :: tmp","tags":"","loc":"proc/li_remove.html","title":"li_remove – ooflib"},{"text":"public  subroutine lists_test() Arguments None Subroutines subroutine integer_list_test() Arguments None subroutine check_array(iter, array) Arguments Type Intent Optional Attributes Name class( iterator ), intent(inout) :: iter integer, intent(in) :: array (:)","tags":"","loc":"proc/lists_test.html","title":"lists_test – ooflib"},{"text":"Uses: objects lists iterators collections @author Jiri Furst\n The module defines simple queue Derived Types type, public, extends( collection ) :: queue Components Type Visibility Attributes Name Initial type( list ), private :: container Type-Bound Procedures procedure, public :: is_empty procedure, public :: size procedure, public :: push procedure, public :: add procedure, public :: top procedure, public :: pop procedure, public :: clear procedure, public :: iterator => q_iterator Description The simple queue","tags":"","loc":"module/queues.html","title":"queues – ooflib"},{"text":"Uses: iterators @author Jiri Furst\n The module defines iterators for rank-1 arrays Derived Types type, public, extends( iterator ) :: array_iterator Components Type Visibility Attributes Name Initial integer, private :: idx class(*), private, pointer :: array (:) => null() Type-Bound Procedures procedure, public :: has_next => ai_has_next procedure, public :: next => ai_next Description The iterator over an array\n @extends iterators::iterator","tags":"","loc":"module/array_iterators.html","title":"array_iterators – ooflib"},{"text":"Uses: objects iterators @author Jiri Furst\n The module defines abstract collections Abstract Interfaces abstract interface private  subroutine coll_add (self, o) Arguments Type Intent Optional Attributes Name class( collection ), intent(inout) :: self class(*), intent(in) :: o Description Interface for collection::add\n \\param[in] o - the object to add abstract interface private  function coll_size (self) Arguments Type Intent Optional Attributes Name class( collection ), intent(in) :: self Return Value integer abstract interface private  function coll_iterator (self) Arguments Type Intent Optional Attributes Name class( collection ), intent(in), target :: self Return Value class( iterator ),\n  allocatable Description Interface for collection::add\n \\param[in] o - the object to add","tags":"","loc":"module/collections.html","title":"collections – ooflib"},{"text":"Uses: objects @author Jiri Furst\n The module defines an abstract class iterator Abstract Interfaces abstract interface private  function iterator_next (self) Arguments Type Intent Optional Attributes Name class( iterator ), intent(inout) :: self Return Value class(*),\n  pointer abstract interface private  function iterator_has_next (self) Arguments Type Intent Optional Attributes Name class( iterator ), intent(in) :: self Return Value logical","tags":"","loc":"module/iterators.html","title":"iterators – ooflib"},{"text":"The module defines class object which is a root of the class hierarchy Derived Types type, public :: object Type-Bound Procedures generic, public :: operator(==) => equals Compares with other object procedure, public :: equals Description The root of class hierarchy","tags":"","loc":"module/objects.html","title":"objects – ooflib"},{"text":"@author Jiri Furst\n The module implements oprations with rational numbers Interfaces public interface real private  function real_rat (rat) Arguments Type Intent Optional Attributes Name type( rational ), intent(in) :: rat Return Value real(kind=dbl) private interface assignment(=) private  subroutine assign_int (c, a) Arguments Type Intent Optional Attributes Name type( rational ), intent(out) :: c integer, intent(in) :: a private interface operator(+) private  function add_rat_rat (a, b) Arguments Type Intent Optional Attributes Name type( rational ), intent(in) :: a type( rational ), intent(in) :: b Return Value type( rational ) private  function add_int_rat (b, a) Arguments Type Intent Optional Attributes Name integer, intent(in) :: b type( rational ), intent(in) :: a Return Value type( rational ) private  function add_rat_int (a, b) Arguments Type Intent Optional Attributes Name type( rational ), intent(in) :: a integer, intent(in) :: b Return Value type( rational ) private interface operator(-) private  function sub_rat_rat (a, b) Arguments Type Intent Optional Attributes Name type( rational ), intent(in) :: a type( rational ), intent(in) :: b Return Value type( rational ) private  function sub_int_rat (b, a) Arguments Type Intent Optional Attributes Name integer, intent(in) :: b type( rational ), intent(in) :: a Return Value type( rational ) private  function sub_rat_int (a, b) Arguments Type Intent Optional Attributes Name type( rational ), intent(in) :: a integer, intent(in) :: b Return Value type( rational ) private interface operator(*) private  function mul_rat_rat (a, b) Arguments Type Intent Optional Attributes Name type( rational ), intent(in) :: a type( rational ), intent(in) :: b Return Value type( rational ) private  function mul_int_rat (b, a) Arguments Type Intent Optional Attributes Name integer, intent(in) :: b type( rational ), intent(in) :: a Return Value type( rational ) private  function mul_rat_int (a, b) Arguments Type Intent Optional Attributes Name type( rational ), intent(in) :: a integer, intent(in) :: b Return Value type( rational ) private interface operator(/) private  function div_rat_rat (a, b) Arguments Type Intent Optional Attributes Name type( rational ), intent(in) :: a type( rational ), intent(in) :: b Return Value type( rational ) private  function div_rat_int (a, b) Arguments Type Intent Optional Attributes Name type( rational ), intent(in) :: a integer, intent(in) :: b Return Value type( rational ) private  function div_int_rat (b, a) Arguments Type Intent Optional Attributes Name integer, intent(in) :: b type( rational ), intent(in) :: a Return Value type( rational )","tags":"","loc":"module/rationals.html","title":"rationals – ooflib"},{"text":"Uses: objects iterators collections @author Jiri Furst\n The module defines single linked list of generic objects Derived Types type, private, extends( object ) :: list_item Components Type Visibility Attributes Name Initial class( list_item ), public, pointer :: next => null() class(*), public, allocatable :: val type, public, extends( collection ) :: list Components Type Visibility Attributes Name Initial integer, private :: size_ = 0 type( list_item ), private :: first_ptr type( list_item ), private :: last_ptr Type-Bound Procedures procedure, public :: size => lst_size procedure, public :: add => lst_add procedure, public :: iterator => lst_iterator Description The single linked list of generic objects type, public, extends( iterator ) :: list_iterator Components Type Visibility Attributes Name Initial class( list ), private, pointer :: parent => null() class( list_item ), private, pointer :: item => null() class( list_item ), private, pointer :: last => null() Type-Bound Procedures procedure, public :: has_next => li_has_next procedure, public :: next => li_next procedure, public :: remove => li_remove","tags":"","loc":"module/lists.html","title":"lists – ooflib"},{"text":"Uses: array_iterators lists queues rationals","tags":"","loc":"program/ooflib_test.html","title":"ooflib_test – ooflib"}]}